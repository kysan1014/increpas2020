# day12

함수의 오버로딩 (Overloading: 함수의 중첩) 
-> 원칙적으로 같은 클래스 내에서는 함수의 이름은 모두 달라야 한다.
	같은 크래스 네에서 이름이 같은 함수가 존재하면 에러가 발생한다.
	
	이렇게 작성하다 보면 가독성에 문제가 생긴다.
	즉, 가독성이란 ?
	함수의 이름만 봐도 그 함수가 어떤 기능을 가지고 있는 함수인지 알아야 하는데,
	함수의 이름을 모두 다르게 만든다면
	-> 가독성에 있어 문제가 발생할 수 있따
	
	이런 문제를 해결하기 위해서 도입된 문법이 있는데,
	이 문법이 함수의 오버로딩(함수의 중첩)이다.
	
	오버로딩이란 ??
	같은 클래스내에서 같은 이름의 함수를 만들 수 있다.
	단, 조건은 반드시 지켜줘야 한다.
	
	***
	1. 함수의 이름이 같아야함
	2. 매개변수의 갯수, 순서, 형채 중 하나 이상이 달라야 한다.
		매개변수 리스트의 형태가 달라야 한다.
	3. 반환값과 상관이 전혀 없다.
	
	예 )
	
		void abc() {}
		
		void abc(int a) {}
		
		int abc(int a, int c) { return a + c; }
		
		float abc() {} ------------------------------ X
		
		void abc(int a, String s) {}
		
		void abc(String s, int a) {} ---------------- O
		
		
	결론 ) 
	
		함수를 호출할 때 정확한 함수를 선택할 수 있도록 해야 한다.
		
		public class Test01 {
		
			abc(); - 1 번 호출
 		
			abc(int a); - 2 번 호출
		
			abc(int a, int c); - 3 번 호출
		
		}
		
		void abc() {} ------------------------------------- 1
		
		void abc(int a) {} -------------------------------- 2
		
		int abc(int a, int c) { return a + c; } ----------- 3
		
	참고 )
	
		다른 사람이 만든 클래스(API 등)에도 오버로딩이 구현된 함수를 볼 수 있다.
		이들 함수를 사용하는 방법
		원하는 기능을 하는 함수가 요구하는 데이터를 형태와 순서에 맞게 
		정확히 입력하여 호출하면 된다.
		
		참고 )
		
			형태가 맞지 않더라도 실행되는 경우가 있는데...
			이런 경우는 자동 형변환이 되는 경우는 형태가 맞지 않더라도 실행이 된다.
		


생성자 함수(Constructor)

==> 클래스를 사용하기 위하여 new 시키는 순간 자동 실행되는 함수.
	
	예 ]
	
		class Test {
		}
		
		Test t = new Test();
		
	즉, 클래스를 new 시키는 개념은 오브젝트(실행가능한 물건)로 만들어서
	실행을 한다는 개념이다.
	따라서 이 때 실행한다는 것은 결국 오브젝트를 만드는 순간에 뭔가를 실행한다는 것이다.
	이것은 물건을 만들때 필요한 뭐가 조치를 한다는 개념이다.
	==> 결론적으로
		생성자 함수는 물건을 실제로 만들기 위한 함수이다.
		
	클래스는 한가지 목적을 달성하기 위해서 만들어지는 프로그램의 최소단위이다.
	이 안에는 그 목적을 달성하기 위한 변수, 함수(멤버)로 구성된다.
	하지만 그 목적을 달성하기 위해서는 가장 기본적인 어떤 조치가 필요한 경우가 있을 것이다.
	
	예 ]
		String
			문자열을 관리하기 위한 목적으로 만들어진 클래스이다.
			==> 문자열을 기억하고 있어야 한다.
			
		FileOutputStream
			파일에 내용을 기록하기 위한 목적으로 만들어진 클래스이다.
			==> 파일을 사용할 수 있도록 열어놔야 할 것이다.
			
		Socket
			네트워크를 구성하기 위한 목적으로 만들어진 클래스이다.
			==> 상대방과 접속은 이루어져야 한다.
			
	프로그램은 프로그램답게 뭔가를 처리하기 위해서(기능)는 함수가 필요하고
	위의 경우를 보자면 각가의 클래스는 오브젝트(인스턴스)로 만들어지는 순간
	그 클래스만의 초소한의 일을 할 필요가 있다.
	
	
생성자 함수를 만드는 방법
	
	규칙 ]
		
		1. 함수의 이름은 반드시 클래스 이름과 대소문자까지 동일해야 한다.
		2. 반환값은 절대로 가지면 안되고 void라고 적어도 안된다.
		3. 매개변수는 가질 수 있다.
		
		
	예 ]
		
		class Test {
			public Test(){	------------------ 기본 생성자 함수
			}
			
			public Test(String name){	------ 생성자 함수 오버로딩
			}
			
			int Test(int no){	-------------- 생성자 함수는 반환값을 가지면 안된다.
			}
			
			test(float no){	------------------- 생성자 함수는 클래스이름과 대소문자까지 동일해야 한다. X
			}
		}
		
	참고 ]
		
		생성자 함수는 오버로딩이 가능하다.
		==> 생성자 함수는 여러개 만들 수 있다.
		
		왜??
		<== 
			필요하면 그 클래스가 기본적으로 해야할 일이
			조금씩 달려질 수 있으므로...
			
			예 ]
				
				문자열 데이터가 준비되어있다면 
					==> new String("abcd");
					
				만약 아직 문자열이 준비되어있지 않고 특정순간 이후에 결정이 된다면....
					==> String str = new String();
						.....
						str = "abcd";
						
		여러개의 생성자 함수가 있다는 것은
		new 시킬때 필요한 생성자 함수를 선택할 수 있어야 한다.
		==> new 시키는 문법을 보면 답이 나온다.
			new 시키는 문법은 바로 생성자 함수를 호출하는 문법이다.
			
			예 ]
				
				class Test {
					Test(){}
					Test(int a){}
				}
					
				// 두 함수가 일반함수일 경우
				t.Test();
				t.Test(5);
				로 호출한다.
				
				생성자는 일반함수 처럼 사용하는 것이 아니고
				new Test();
				==> Object를 만드는 문법
				new Test(5);
				==> Object를 만드는 문법, 정수를 입력하면서...
				
		결론 ]
			
			매개변수가 있는 생성자 함수를 호출하기 위해서는
			new 시킬때 매개변수가 필요한 데이터를 주면서 new 시키면 된다.
			<== 데이터가 미리 준비되어 있어야 한다.
			
		참고 ]
			기본 생성자(Default Constructor)
			==> 매개변수가 하나도 없는 생성자 함수를 지칭하는 용어.
				예 ]
					Test(){}	<---  기본 생성자라 부른다.
					
		***
		자바는 생성자 함수가 없어도 new 시킬 수 있다.
		하지만 이것은 생성자 함수를 이용하지 않는 것이 아니고
		JVM이 기본생성자를 내부적으로 만들어 준 후
		이 생성자를 이용하는 것이다.
		
		결론적으로 
		자바는 new 시킬때 마다 반드시 생성자 함수를 이용하게 된다.
		
		***
		만약 개발자가 생성자 함수를 한개라도 작성하게 되면
		JVM은 기본 생성자를 만들어주지 않는다. 
		==> 매개변수가 있는 형태로 생성자를 정의하면 기본 생성자를 사용할 수 없게 된다.
		즉, 내부적으로 기본생성자를 만드는 경우는
		오직 개발자가 생성자 함수를 한개도 만들지 않았을 경우에 한해서 
		JVM이 기본 생성자를 만들게 된다.
		
		따라서
		생성자를 정의하게 될 경우는
		되도록이면 기본 생성자의 내용이 없더라도 
		정의해두는 것이 좋다.
		
생성자 함수 이용방법
	
	결론 ]
		생성자 함수는 그 클래스를 어떻게 new 시킬지 알려주는 함수이다.
		==> 준비된 데이터에 따라서 new 시킬때 입력하는 데이터가 달라진다.
		
		즉, 생성자함수가 요구하는 매개변수가 무엇인지를 보면
		그 클래스를 객체로 만들 수 있는 방법이 도출이 된다.
		
--------------------------------------------------------------------------------------------------------

참고 ]
	
	this()
	==> 생성자 함수는 원칙적으로 개발자가 직접 호출할 수 없다.
	
		현재 생성자를 싱행하는 도중에 다른 생성자(오버로딩된 생성자)를
		강제로 호출하는 유일한 방법.
		
	***
	규칙
		1. 반드시 생성자 함수내부에서만 사용해야 한다.
			==> 일반함수 내에서는 사용할 수 없다.
		2. 반드시 생성자 함수의 첫 문장으로 사용해야 한다.
			this() 이전에 다른 문장이 있으면 에러가 발생한다.
			
	왜 사용해야 하는가???
		==> 클래스는 한가지 목적을 가진 프로그램의 집합이다.
			물론 기본적인 작업이 조금은 달라질 수 있지만
			그 틀 자체는 변하지 않을 것이다.
			
			예 ]
				Socket은 접속할 대상의 주소와 포트번호는 바뀌겠지만
				결론은 접속을 시도해야 할 것이다.
				String은 데이터의 형태가 달라지겠지만
				결론은 문자열을 만들어야 할 것이다.
				
			그러므로 생성자 함수가 하는 기능은 거의 비슷할 것이다.
			기능이 비슷하다는 의미는 
			내부 코드의 내용도 비슷하다는 것이다.
			따라서 같은 코드 내용이 중복되어서 작성되어질 것이다.
			이 작업을 조금이라도 단순화 시켜주기 위해서
			생성자 끼리는 서로 필요하면 상대방을 이용할 수 있게 
			만들어 놓은 문법이다.
			
--------------------------------------------------------------------------------------------------------

향상된 for 명령 ( forEach 반복문 )
==> 이 명령은 오직 데이터가 배열이거나 컬렉션일 경우에만 사용할 수 있는 반복문
	이 명령은 Java 버젼 1.4 이후 추가된 명령이다.
	
	형식 ]
		
		for(데이터타입 변수이름1 : 배열 또는 컬렉션){
		
		}
		
	참고 ]
		변수이름1은 배열 또는 컬렉션에 저자된 데이터와 타입이 일치해야 한다.
		
	의미 ]
		배열 또는 컬렉션이 가진 실제 데이터의 갯수만큼 자동 반복하면서
		실제 데이터를 주어진 변수(변수이름1)에 한개씩 기억되면서 반복한다.
		
		
	예 ]
		
		int[] no = {1, 2, 3, 4, 5};
		
		for(int n : no){
			// n의 타입은 no 배열의 데이터가 int 이므로 int 타입으로 만들어야 한다.
			
			// 1. 첫번째 회차에는 인덱스 0 에 들어있는 데이터 1 을 꺼내서 n 에 대입을 해주고
			//		그후 반복문 블럭을 실행하고
			// 2. 두번째 회차에는 인덱스 1 에 들어있는 데이터 2 을 꺼내서 n 에 대입을 해주고
			//		그후 반복문 블럭을 실행하고
			// ....
		}
	
--------------------------------------------------------------------------------------------------------

가변인자
==> 우리가 함수를 만들때
	그 함수가 가지고있는 매개변수와 동일할 갯수, 형태, 순서를 이용해서 함수를 호출해야 한다.
	
	
	예 ]
		
		void abc(int a){}
		
		==> abc(10);
		
		void abc(int a, int b){}
		
		==> abc(10, 5);
		
	그런데 만약 입력해야할 데이터의 갯수를 지정할 수 없으면????
	배열을 사용하면 되긴하지만....
	
	==> 바로 이런경우 사용할 수 있는 개념의 매개변수가 "가변인자" 이다.
	==> 이것은 데이터의 갯수에 상관없이 모든 데이터를 다 받을 수 있도록 하는 것.
	
형식 ]
	
	[접근지정자]	[속성]	반환값타입	함수이름(데이터타입...매개변수이름){
	
	}
	
	예 ]
		
		void abc(int...num){}
		
		==> 
		abc(1);
		abc(1, 2);
		abc(1, 2, 3, 4, 5);
		
	주의 ]
		가변인자의 변수는 자동 배열 변수가 된다.
		따라서 배열 변수처럼 사용해야 한다.
		
		예 ]
			for(int no : num){
				System.out.println(no);
			}
		
	주의 ]
		가변인자 앞에는 다른 매개변수를 선언해도 상관없다.
		가변인자 뒤에는 다른 매개변수를 선언할 수 없다.
		
		void abc(String s, int...num){	-------------- O
		}
		
		void abc(int...num, String s){	--------------- X
		}
		
---------------------------------------------------------------------------------------------
			
			
			